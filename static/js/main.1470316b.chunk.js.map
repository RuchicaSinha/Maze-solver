{"version":3,"sources":["models/Wall.js","features/canvas/mazeSlice.js","features/canvas/canvas.js","utils/shuffle.js","utils/sleep.js","utils/randInt.js","features/solver/solverSlice.js","features/solver/solver.js","App.js","app/store.js","serviceWorker.js","index.js"],"names":["directions","N","S","E","W","opposite","dx","dy","genMaze","size","maze","i","row","j","push","walls","bgColor","mazeSlice","createSlice","name","initialState","width","height","reducers","newMaze","state","action","payload","setMaze","carveWall","x","y","direction","nx","ny","setCellColor","color","actions","selectMaze","drawLine","ctx","p1","p2","beginPath","prevCap","lineCap","prevWidth","lineWidth","strokeStyle","moveTo","lineTo","stroke","fillCell","dim","p","prev","fillStyle","fillRect","drawCellWalls","tl","tr","bl","br","MazeCanvas","props","canvasRef","useRef","useSelector","useEffect","canvas","current","getContext","clearRect","ref","shuffle","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","sleep","ms","Promise","resolve","setTimeout","randInt","min","max","solverSlice","moves","clearMoves","addMove","move","selectMoves","solver","SolverCanvas","recursiveIteration","dispatch","a","dirs","dir","m","JSON","parse","stringify","sx","sy","App","useState","setSize","useDispatch","className","class","for","value","onInput","e","target","id","type","onClick","recursiveBacktrack","configureStore","reducer","solverReducer","mazeReducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","store","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1470316b.chunk.js","sourcesContent":["export const directions = {\n    N: 1, //rightmost-bit\n    S: 2, \n    E: 4,\n    W: 8,\n}\n\nexport const opposite = {\n    N: directions.S,\n    S: directions.N,\n    E: directions.W,\n    W: directions.E\n}\n\nexport const dx = {\n    N: 0,\n    S: 0,\n    E: 1,\n    W: -1\n}\n\nexport const dy = {\n    N: -1,\n    S: 1,\n    E: 0,\n    W: 0,\n}\n","import { createSlice } from \"@reduxjs/toolkit\";\nimport { directions, dx, dy, opposite } from \"../../models/Wall\";\n\nfunction genMaze(size) {\n    const maze = [];\n    for (let i = 0; i < size; i++) {\n        const row = [];\n        for (let j = 0; j < size; j++) {\n            row.push({\n                walls: 0,\n                bgColor: 'rgba(0,0,0,0)',\n            });\n        }\n        maze.push(row);\n    }\n    return maze;\n}\n\nexport const mazeSlice = createSlice({\n    name: 'maze',\n    initialState: {\n        maze: {\n            width: 10,\n            height: 10,\n            maze: genMaze(10),\n        }\n    },\n    reducers: {\n        newMaze: (state, action) => {\n            const { size } = action.payload;\n            state.maze.width = size;\n            state.maze.height = size;\n            state.maze.maze = genMaze(size);\n        },\n        setMaze: (state, action) => {\n            const { maze } = action.payload;\n            state.maze.maze = maze;\n        },\n        carveWall: (state, action) => {\n            const { x, y, direction } = action.payload;\n            const nx = x + dx[direction];\n            const ny = y + dy[direction];\n\n            state.maze.maze[y][x].walls |= directions[direction];\n            state.maze.maze[ny][nx].walls |= opposite[direction];\n        },\n        setCellColor: (state, action) => {\n            const { x, y, color } = action.payload;\n            state.maze.maze[y][x].bgColor = color;\n        }\n    }\n});\n\nexport const { newMaze, setMaze, carveWall, setCellColor } = mazeSlice.actions;\nexport const selectMaze = state => state.maze.maze;\n\nexport default mazeSlice.reducer;\n","import React, { useEffect, useRef } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { directions } from \"../../models/Wall\";\nimport { selectMaze } from \"./mazeSlice\";\n\nfunction drawLine(ctx, p1, p2) {\n    ctx.beginPath();\n    const prevCap = ctx.lineCap;\n    const prevWidth = ctx.lineWidth;\n    ctx.lineCap = \"round\";\n    ctx.lineWidth = 3;\n    ctx.strokeStyle = \"#908978\";\n    ctx.moveTo(p1[0], p1[1]);\n    ctx.lineTo(p2[0], p2[1]);\n    ctx.stroke();\n    ctx.lineCap = prevCap;\n    ctx.lineWidth = prevWidth;\n    //lineStroke - \n}\n\nfunction fillRect(ctx, p, dim, color) {\n    const prev = ctx.fillStyle;\n    ctx.fillStyle = color;\n    ctx.fillRect(p[0], p[1], dim, dim);\n    ctx.fillStyle = prev;\n}\n\nfunction fillCell(ctx, dim, color, x, y) {\n    const tl = [x * dim, y * dim];\n    fillRect(ctx, tl, dim, color);\n}\n\nfunction drawCellWalls(ctx, walls, dim, x, y) {\n    const tl = [x * dim, y * dim];\n    const tr = [x * dim + dim, y * dim];\n    const bl = [x * dim, y * dim + dim];\n    const br = [x * dim + dim, y * dim + dim];\n    if ((walls & directions.N) === 0) { //0110 and 0001\n        drawLine(ctx, tl, tr);\n    }\n\n    if ((walls & directions.E) === 0) { //0110 and 0100\n        drawLine(ctx, tr, br);\n    }\n\n    if ((walls & directions.W) === 0) {\n        drawLine(ctx, tl, bl);\n    }\n\n    if ((walls & directions.S) === 0) {\n        drawLine(ctx, bl, br);\n    }\n}\n\nexport function MazeCanvas(props) {\n    const { size } = props;\n    const canvasRef = useRef(null);\n\n    const maze = useSelector(selectMaze);\n\n    useEffect(() => {\n        const dim = size / maze.width;\n        const canvas = canvasRef.current\n        const ctx = canvas.getContext('2d')\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        for (let i = 0; i < maze.width; i++) {\n            for (let j = 0; j < maze.height; j++) {\n                fillCell(ctx, dim, maze.maze[j][i].bgColor, i, j);\n            }\n        }\n        for (let i = 0; i < maze.width; i++) {\n            for (let j = 0; j < maze.height; j++) {\n                drawCellWalls(ctx, maze.maze[j][i].walls, dim, i, j)\n            }\n        }\n    }, [maze, size]);\n\n    return <canvas ref={canvasRef} width={size} height={size} />\n}","export default function shuffle(array) {\n    var currentIndex = array.length, temporaryValue, randomIndex;\n  \n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n  \n    return array;\n  }","export default function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }","export default function randInt(min, max) { // min and max included \n    return Math.floor(Math.random() * (max - min + 1) + min);\n}","import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const solverSlice = createSlice({\n    name: 'solver',\n    initialState: {\n        moves: [[0,0], [0,1], [0,2]],\n    },\n    reducers: {\n        clearMoves: state => {\n            state.moves = [];\n        },\n        addMove: (state, action) => {\n            const { move } = action.payload;\n            state.moves.push(move);\n        }\n    },\n})\n\nexport const { clearMoves, addMove } = solverSlice.actions;\n\nexport const selectMoves = state => state.solver.moves;\n\nexport default solverSlice.reducer;\n","import React, { useEffect, useRef } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { selectMaze } from \"../canvas/mazeSlice\";\nimport { selectMoves } from \"./solverSlice\";\n\nexport function SolverCanvas(props) {\n    const { size } = props;\n    const canvasRef = useRef(null);\n    // const dispatch = useDispatch();\n\n    const maze = useSelector(selectMaze);\n    const moves = useSelector(selectMoves);\n\n    useEffect(() => {\n        // const dim = size/maze.width;\n        const canvas = canvasRef.current;\n\n        const ctx = canvas.getContext('2d')\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }, [maze, moves, size])\n\n    return <canvas ref={canvasRef} width={size} height={size} />\n}\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { MazeCanvas } from './features/canvas/canvas';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { carveWall, newMaze, selectMaze, setCellColor } from './features/canvas/mazeSlice';\r\nimport { directions, dx, dy, opposite } from './models/Wall';\r\nimport shuffle from './utils/shuffle';\r\nimport sleep from './utils/sleep';\r\nimport randInt from './utils/randInt';\r\nimport { SolverCanvas } from './features/solver/solver';\r\n\r\n\r\nasync function recursiveIteration(x, y, maze, dispatch) {\r\n  const dirs = [\"N\", \"S\", \"E\", \"W\"];\r\n  shuffle(dirs); //W\r\n  await dispatch(setCellColor({\r\n    x,\r\n    y,\r\n    color: \"rgb(116, 3, 182)\"\r\n  }));\r\n  // xy 00, shuffle EWSN\r\n  // xy 10, shuffle NEWS\r\n  // xy 20\r\n\r\n  //xy 01\r\n  for (const dir of dirs) { //dir E, starting 00\r\n    const nx = x + dx[dir]; \r\n    const ny = y + dy[dir];\r\n    if ((nx >= 0 && nx < maze.width) && (ny >= 0 && ny < maze.height) && (maze.maze[ny][nx].walls === 0)) {\r\n      maze.maze[y][x].walls |= directions[dir]; //wall initally 0000, 0100\r\n      maze.maze[ny][nx].walls |= opposite[dir];\r\n      await dispatch(carveWall({\r\n        x,\r\n        y,\r\n        direction: dir\r\n      }));\r\n      await sleep(5);\r\n      await recursiveIteration(nx, ny, maze, dispatch);\r\n    }\r\n  }\r\n  await dispatch(setCellColor({\r\n    x,\r\n    y,\r\n    color: \"rgba(0,0,0,0)\"\r\n  }));\r\n  await sleep(5);\r\n}\r\n\r\nasync function recursiveBacktrack(maze, dispatch) {\r\n  const m = JSON.parse(JSON.stringify(maze));\r\n  const sx = randInt(0, maze.width - 1);\r\n  const sy = randInt(0, maze.height - 1);\r\n  await recursiveIteration(sx, sy, m, dispatch);\r\n}\r\n\r\nfunction App() {\r\n  const [size, setSize] = useState(10);\r\n  const dispatch = useDispatch();\r\n  const maze = useSelector(selectMaze);\r\n  return (\r\n    <div className=\"App\">\r\n      <div class=\"container\">\r\n        <h1>Maze Solver</h1>\r\n      </div>\r\n\r\n      <div>\r\n          <label for=\"number\">Enter Maze Size</label>\r\n          <input value={size} onInput={e => setSize(e.target.value)} id=\"number\" type=\"number\"></input>\r\n          <button onClick={() => dispatch(newMaze({ size }))}>Initialize!</button>\r\n          <br></br>\r\n          <br></br>\r\n\r\n          <label for=\"generationAlgo\">Select Maze generation algorithm</label>\r\n          <select id=\"generationAlgo\">\r\n            <option value=\"recursive\">Recursive Backtracking</option>\r\n            <option value=\"kruskal\">Kruskal Algorithm</option>\r\n          </select>\r\n          <button onClick={() => { recursiveBacktrack(maze, dispatch) }}>Generate Maze!</button>\r\n\r\n          <br></br>\r\n          <br></br>\r\n\r\n          <label for=\"solvingAlgo\">Select Maze solving algorithm</label>\r\n          <select id=\"solvingAlgo\">\r\n            <option value=\"recursive\">Recursive Backtracking</option>\r\n            <option value=\"kruskal\">Kruskal Algorithm</option>\r\n          </select>\r\n          <button>Solve Maze!</button>\r\n\r\n          <br></br>\r\n          <br></br>\r\n        </div>\r\n      \r\n\r\n      <div className=\"canvasContainer\">\r\n        <MazeCanvas size={500} />\r\n        <SolverCanvas size={500} />\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { configureStore } from '@reduxjs/toolkit';\r\nimport solverReducer from '../features/solver/solverSlice';\r\nimport mazeReducer from '../features/canvas/mazeSlice';\r\n\r\nexport default configureStore({\r\n  reducer: {\r\n    solver: solverReducer,\r\n    maze: mazeReducer,\r\n  },\r\n});\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport store from './app/store';\r\nimport { Provider } from 'react-redux';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}